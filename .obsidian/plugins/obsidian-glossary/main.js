/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  GlossaryRenderer: () => GlossaryRenderer,
  default: () => ObsidianGlossary
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  glossaryFilePath: "glossary.md"
};
var ObsidianGlossary = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.glossaryVault = {};
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new SampleSettingTab(this.app, this));
      this.app.vault.on("modify", (file) => {
        if (file.path === this.settings.glossaryFilePath) {
          this.getDefinitionList(this.settings.glossaryFilePath);
        }
      });
      if (this.app.workspace.layoutReady) {
        this.init();
      } else {
        this.app.workspace.onLayoutReady(() => this.init());
      }
    });
  }
  init() {
    return __async(this, null, function* () {
      this.getDefinitionList(this.settings.glossaryFilePath);
      this.registerMarkdownPostProcessor((element, context) => {
        const codeblocks = element.querySelectorAll("p, li, span");
        for (let index = 0; index < codeblocks.length; index++) {
          const codeblock = codeblocks.item(index);
          const text = codeblock.innerText.trim();
          if (text) {
            context.addChild(new GlossaryRenderer(codeblock, this.glossaryVault));
          }
        }
      });
    });
  }
  onunload() {
  }
  getDefinitionList(glossaryFilePath) {
    return __async(this, null, function* () {
      const glossaryContent = yield this.app.vault.adapter.read(glossaryFilePath);
      if (glossaryContent) {
        this.glossaryVault = this.parseDefinitionList(glossaryContent);
      } else {
        console.warn(`No glossary file found. Create a markdown file on this path: ${glossaryFilePath}. (Editable in settings.)`);
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  parseDefinitionList(text) {
    const lines = text.split("\n").filter(Boolean);
    const glossaryDefinitionMarkers = [" ", "	", ":", "|"];
    let currentPhrase = "";
    const result = lines.reduce((acc, line) => {
      if (glossaryDefinitionMarkers.includes(line[0])) {
        acc[currentPhrase].push(line.substring(1).trim());
        acc[currentPhrase] = acc[currentPhrase].filter(Boolean);
      } else {
        currentPhrase = line;
        acc[line] = [];
      }
      return acc;
    }, {
      "": []
    });
    delete result[""];
    return result;
  }
};
var GlossaryRenderer = class extends import_obsidian.MarkdownRenderChild {
  constructor(containerEl, glossary) {
    super(containerEl);
    this.containerEl = containerEl;
    this.glossary = glossary;
  }
  onload() {
    const origContent = this.containerEl.innerHTML;
    let newContent = origContent;
    Object.keys(this.glossary).forEach((key) => {
      if (newContent.indexOf(key) > -1) {
        const title = this.glossary[key].join("\n");
        newContent = newContent.split(key).join(`<span class="obsidian-glossary-item" title="${title}">${key}</span>`);
      }
    });
    if (newContent !== origContent) {
      const span = document.createElement("SPAN");
      span.innerHTML = newContent;
      this.containerEl.replaceWith(span);
    }
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.glossaryFilePath).onChange((value) => __async(this, null, function* () {
      console.log("Secret: " + value);
      this.plugin.settings.glossaryFilePath = value;
      yield this.plugin.saveSettings();
    })));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duUmVuZGVyQ2hpbGQsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nLCBWaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG4vLyBSZW1lbWJlciB0byByZW5hbWUgdGhlc2UgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyFcblxuaW50ZXJmYWNlIE9ic2lkaWFuR2xvc3NhcnlTZXR0aW5ncyB7XG5cdGdsb3NzYXJ5RmlsZVBhdGg6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEdsb3NzYXJ5VmF1bHQge1xuXHRbcGhyYXNlOiBzdHJpbmddOiBzdHJpbmdbXVxufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBPYnNpZGlhbkdsb3NzYXJ5U2V0dGluZ3MgPSB7XG5cdGdsb3NzYXJ5RmlsZVBhdGg6ICdnbG9zc2FyeS5tZCdcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JzaWRpYW5HbG9zc2FyeSBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBPYnNpZGlhbkdsb3NzYXJ5U2V0dGluZ3M7XG5cdGdsb3NzYXJ5VmF1bHQ6IEdsb3NzYXJ5VmF1bHQgPSB7fTtcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0YXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cblx0XHR0aGlzLmFwcC52YXVsdC5vbignbW9kaWZ5JywgKGZpbGUpID0+IHtcblx0XHRcdGlmIChmaWxlLnBhdGggPT09IHRoaXMuc2V0dGluZ3MuZ2xvc3NhcnlGaWxlUGF0aCkge1xuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHJlLWdlbmVyYXRlIHRoZSBkZWZpbml0aW9uTGlzdFxuXHRcdFx0XHR0aGlzLmdldERlZmluaXRpb25MaXN0KHRoaXMuc2V0dGluZ3MuZ2xvc3NhcnlGaWxlUGF0aCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAodGhpcy5hcHAud29ya3NwYWNlLmxheW91dFJlYWR5KSB7XG5cdFx0XHR0aGlzLmluaXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4gdGhpcy5pbml0KCkpO1xuXHRcdH1cblxuXHR9XG5cblx0YXN5bmMgaW5pdCgpIHtcblxuXHRcdHRoaXMuZ2V0RGVmaW5pdGlvbkxpc3QodGhpcy5zZXR0aW5ncy5nbG9zc2FyeUZpbGVQYXRoKTtcblxuXHRcdHRoaXMucmVnaXN0ZXJNYXJrZG93blBvc3RQcm9jZXNzb3IoKGVsZW1lbnQsIGNvbnRleHQpID0+IHtcblx0XHRcblx0XHRcdGNvbnN0IGNvZGVibG9ja3MgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwLCBsaSwgc3BhblwiKTsgXG5cblx0XHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjb2RlYmxvY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0XHRjb25zdCBjb2RlYmxvY2sgPSBjb2RlYmxvY2tzLml0ZW0oaW5kZXgpO1xuXHRcdFx0XHRjb25zdCB0ZXh0ID0gY29kZWJsb2NrLmlubmVyVGV4dC50cmltKCk7XG5cdFx0XHRcdGlmKHRleHQpIHtcblx0XHRcdFx0XHRjb250ZXh0LmFkZENoaWxkKG5ldyBHbG9zc2FyeVJlbmRlcmVyKGNvZGVibG9jaywgdGhpcy5nbG9zc2FyeVZhdWx0KSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdH0pO1xuXG5cblx0fVxuXG5cdG9udW5sb2FkKCkge1xuXG5cdH1cblxuXHRhc3luYyBnZXREZWZpbml0aW9uTGlzdChnbG9zc2FyeUZpbGVQYXRoOiBzdHJpbmcpIHtcblx0XHRcdFx0XG5cdFx0Y29uc3QgZ2xvc3NhcnlDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKGdsb3NzYXJ5RmlsZVBhdGgpO1xuXHRcdFxuXHRcdGlmIChnbG9zc2FyeUNvbnRlbnQgKSB7XG5cdFx0XHR0aGlzLmdsb3NzYXJ5VmF1bHQgPSB0aGlzLnBhcnNlRGVmaW5pdGlvbkxpc3QoZ2xvc3NhcnlDb250ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKGBObyBnbG9zc2FyeSBmaWxlIGZvdW5kLiBDcmVhdGUgYSBtYXJrZG93biBmaWxlIG9uIHRoaXMgcGF0aDogJHtnbG9zc2FyeUZpbGVQYXRofS4gKEVkaXRhYmxlIGluIHNldHRpbmdzLilgKTtcblx0XHR9XG5cblxuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cblxuXHRwYXJzZURlZmluaXRpb25MaXN0KHRleHQ6IHN0cmluZyk6IEdsb3NzYXJ5VmF1bHQge1xuXG5cdFx0Y29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKS5maWx0ZXIoQm9vbGVhbik7XG5cdFx0Y29uc3QgZ2xvc3NhcnlEZWZpbml0aW9uTWFya2VycyA9IFsnICcsICdcXHQnLCAnOicsICd8J107XG5cdFx0bGV0IGN1cnJlbnRQaHJhc2UgPSAnJztcblxuXHRcdGNvbnN0IHJlc3VsdDogR2xvc3NhcnlWYXVsdCA9IGxpbmVzLnJlZHVjZSgoYWNjOiBHbG9zc2FyeVZhdWx0LCBsaW5lOiBzdHJpbmcpID0+IHtcblx0XHRcdFxuXHRcdFx0aWYoZ2xvc3NhcnlEZWZpbml0aW9uTWFya2Vycy5pbmNsdWRlcyhsaW5lWzBdKSkge1xuXHRcdFx0XHRhY2NbY3VycmVudFBocmFzZV0ucHVzaChsaW5lLnN1YnN0cmluZygxKS50cmltKCkpO1xuXHRcdFx0XHRhY2NbY3VycmVudFBocmFzZV0gPSBhY2NbY3VycmVudFBocmFzZV0uZmlsdGVyKEJvb2xlYW4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaXQncyBhIG5ldyBwaHJhc2Vcblx0XHRcdFx0Y3VycmVudFBocmFzZSA9IGxpbmU7XG5cdFx0XHRcdGFjY1tsaW5lXSA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIHtcblx0XHRcdCcnOiBbXVxuXHRcdH0pO1xuXG5cdFx0ZGVsZXRlIHJlc3VsdFsnJ107XG5cblx0XHRyZXR1cm4gcmVzdWx0O1x0XHRcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgR2xvc3NhcnlSZW5kZXJlciBleHRlbmRzIE1hcmtkb3duUmVuZGVyQ2hpbGQge1xuXHQgXG4gIFx0Y29uc3RydWN0b3IocHVibGljIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCwgcHJpdmF0ZSBnbG9zc2FyeTogR2xvc3NhcnlWYXVsdCkge1xuXHQgIHN1cGVyKGNvbnRhaW5lckVsKTtcbiAgXHR9XG4gIFxuXHRvbmxvYWQoKSB7XG5cblx0XHRjb25zdCBvcmlnQ29udGVudCA9IHRoaXMuY29udGFpbmVyRWwuaW5uZXJIVE1MO1xuXHRcdGxldCBuZXdDb250ZW50OiBzdHJpbmcgPSBvcmlnQ29udGVudDtcblx0XHRPYmplY3Qua2V5cyh0aGlzLmdsb3NzYXJ5KS5mb3JFYWNoKChrZXkpID0+IHtcblx0XHRcdGlmIChuZXdDb250ZW50LmluZGV4T2Yoa2V5KSA+IC0xKSB7XG5cdFx0XHRcdGNvbnN0IHRpdGxlID0gdGhpcy5nbG9zc2FyeVtrZXldLmpvaW4oJ1xcbicpO1xuXHRcdFx0XHRuZXdDb250ZW50ID0gbmV3Q29udGVudC5zcGxpdChrZXkpLmpvaW4oYDxzcGFuIGNsYXNzPVwib2JzaWRpYW4tZ2xvc3NhcnktaXRlbVwiIHRpdGxlPVwiJHt0aXRsZX1cIj4ke2tleX08L3NwYW4+YCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiggbmV3Q29udGVudCAhPT0gb3JpZ0NvbnRlbnQgKSB7XG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU1BBTicpO1xuXHRcdFx0c3Bhbi5pbm5lckhUTUwgPSBuZXdDb250ZW50O1xuXHRcdFx0dGhpcy5jb250YWluZXJFbC5yZXBsYWNlV2l0aChzcGFuKTsgXG5cdFx0fVxuXHR9XG4gIH1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE9ic2lkaWFuR2xvc3Nhcnk7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogT2JzaWRpYW5HbG9zc2FyeSkge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdTZXR0aW5ncyBmb3IgbXkgYXdlc29tZSBwbHVnaW4uJ30pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU2V0dGluZyAjMScpXG5cdFx0XHQuc2V0RGVzYygnSXRcXCdzIGEgc2VjcmV0Jylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgc2VjcmV0Jylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmdsb3NzYXJ5RmlsZVBhdGgpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnU2VjcmV0OiAnICsgdmFsdWUpO1xuXHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLmdsb3NzYXJ5RmlsZVBhdGggPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFzSTtBQVl0SSxJQUFNLG1CQUE2QztBQUFBLEVBQ2xELGtCQUFrQjtBQUNuQjtBQUVBLElBQXFCLG1CQUFyQixjQUE4Qyx1QkFBTztBQUFBLEVBQXJEO0FBQUE7QUFFQyx5QkFBK0IsQ0FBQztBQUFBO0FBQUEsRUFFaEMsQUFBTSxTQUFTO0FBQUE7QUFDZCxZQUFNLEtBQUssYUFBYTtBQUd4QixXQUFLLGNBQWMsSUFBSSxpQkFBaUIsS0FBSyxLQUFLLElBQUksQ0FBQztBQUV2RCxXQUFLLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxTQUFTO0FBQ3JDLFlBQUksS0FBSyxTQUFTLEtBQUssU0FBUyxrQkFBa0I7QUFFakQsZUFBSyxrQkFBa0IsS0FBSyxTQUFTLGdCQUFnQjtBQUFBLFFBQ3REO0FBQUEsTUFDRCxDQUFDO0FBRUQsVUFBSSxLQUFLLElBQUksVUFBVSxhQUFhO0FBQ25DLGFBQUssS0FBSztBQUFBLE1BQ1gsT0FBTztBQUNOLGFBQUssSUFBSSxVQUFVLGNBQWMsTUFBTSxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ25EO0FBQUEsSUFFRDtBQUFBO0FBQUEsRUFFQSxBQUFNLE9BQU87QUFBQTtBQUVaLFdBQUssa0JBQWtCLEtBQUssU0FBUyxnQkFBZ0I7QUFFckQsV0FBSyw4QkFBOEIsQ0FBQyxTQUFTLFlBQVk7QUFFeEQsY0FBTSxhQUFhLFFBQVEsaUJBQWlCLGFB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
